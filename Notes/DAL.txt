DAL - Data Access Layer - Шар доступу до даних
Архітектурний шар, задачею якого є створення інтерфейсів доступу до даних

Без DAL

Window  <---------------------> Entity
"SELECT * FROM Sales"			Sale(reader)
sales.add

- Змішування рівнів абстракції
- Високе зчеплення (coupling) об'єктів
- "S" - єдиний обов'язок (вікно керує SQL запитами)

з DAL
Window   <------------->    DAL                     Entity
salesApi				SalesApi.getAll()   		Sale(reader)
.getAll()               "SELECT * FROM Sales"

+ Знижуємо зчеплення - вікно можна переносити/копіювати
+ Відкриваються можливості "О" (open/close) - можна заміняти SalesApi на нові розробки

Window                          DAL                     Entity
ISaleApi salesApi	---->	SalesApi:ISaleApi   		Sale(reader)
                    \--->  SalesApiNew:ISaleApi
+ "D" - пряму залежність від реалізацій замінюємо на інтерфейсну
! "L" - замість SalesApi можна підставити SalesApiNew без проблем

"І" - розділення інтерфейсів - краще декілька простих інтерфейсів, ніж один великий
У БД сутності, хоч і подібні, але достатньо відмінні між собою. Це ускладнює
створення "єдиного" інтерфейсу. 

Контекст даних - концепція поєднання різних-подібних DataApi (DAO) у єдиний об'єкт

Window                    DAL                         Entity
DataContext             DataContext                   Sale
                       {SaleApi, UserApi}             User


------------------------- Navigation Properties ---------------------------------
Навігаційні властивості - об'єктні властивості (get;set;), які призначені
для отримання ORM-сутностей за наявними реляціями (зв'язками БД)
Наприклад
public class Manager
{
    public Guid IdMainDep  -- звичайна (ORM) властивість
    public Department MainDep  -- навігаційна властивість

Навігаційні властивості мають тип даних з Entity і не є присутніми у БД як
поля таблиці
Ці властивості спрямовують на вже наявні об'єкти контексту даних, тобто при
запиті до них не створюється новий ORM-об'єкт, а знаходиться посилання на
вже наявний

public class Manager <---------  DataContext                     Department
{                                {                               {
  Guid IdMainDep         get        Managers     IdMainDep=Id       Id, Name
  Department MainDep -------------->Departments ---------------->            
  
Для реалізації концепції навігаційних властивостей слід передбачити:
- колекції контексту не повинні перегенеровуватися (GetAll() не повинні
    кожен раз утворювати нові колекції, а зберігати одну). Але при цьому
    щоб не втратити можливість оновлення даних, змінених у БД іншою програмою,
    необхідно закласти параметр для примусового перебудування колекцій
- зв'язок контексту та сутностей стає двобічним: сутність посилається на
    контекст, а контекст - на сутності. Як правило це робиться шляхом реєстрації
    контексту як залежності (у контейнері залежностей), але можлива 
    передача залежності через конструктори сутностей

DataContext {                ManagerApi {                       
    Managers = new(this) -----> _context                        
}                                list.add(new Entity(){          Entity.Manager {
                                   _datacontext = _context}) ------> DataContext _datacontext
                                                                      MainDep{        |
                                                                      get {  _datacontext......} }
Завдання: вивести відомості про SecDep

Зворотна (інверсна) навігаційна властивість - властивість у іншій сутності, на яку
є прямі навігаційні властивості. У наведеному прикладі - це наявність посилань на
співробітників з сутності "відділ". Тип зворотної властивості залежить від типу
відношення (реляції) і, частіше за все, є колекціями (через відношення один-до-багатьох)

Завдання: вивести відомості про кількість сумісників

Д.З.
Реалізувати через навігаційні властивості Entity.Manager
виведення даних про керівника (Chief)
виведення даних про кількість підлеглих (зворотна властивість - у кого є керівником)

